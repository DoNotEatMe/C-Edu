#include <iostream>
#include <cmath>
#include <ctime>

// 1) написать функцию сортировки массива.
// На вход подаётся массив и длина, функция сортирует (выбрать любую сортировку) и выводит отсортированный массив.

// Ещё одна задача: написать функцию (целочисленную)  нахождения индекса введённой переменной из отсортированного массива.
// На вход подаётся: длина массива и переменная. (По условию сделаем так, что переменная находится в массиве 100 проц).

// Особенность: проход по всему массиву с нулевого эт-та не эффективно)
// Думай как по-другому найти индекс эл-та.
// Подсказка: всегда можно отсекать половину)


using namespace std;

void insertion(int arr[100], int l);
void quicksort(int *arr, int l);
void printarr(int arr[100], int l);
void findI(int arr[100], int l, int find);

int main()
{
    int arr[100];
    int l(0), find(0);
    cout << "Insert array lenght: ";
    cin >> l;
     cout << endl
         << "insert nubmer to find: " << endl;
    cin >> find;

    srand(time(0));

    for (int i = 0; i < l; i++)
    {

        arr[i] = rand() % 100;
        cout << arr[i] << " ";
    }

    arr[rand()%l] = find;

    // quicksort(arr, l);
    quicksort(arr, l);
    printarr(arr, l);

   
    

    findI(arr, l, find);
}

void quicksort(int *arr, int l)
{
    /*  быстрая сортировка делит массив на две части и перекидывает элементы влево (меньше) и вправо (больше)
        функция рекурсивная и и вызывает сама себя, сортируя каждые две доли, которые получаются от разделения
        
        входные данные: 41 67 34 0 69
        записываем значение из середины массива = 34
        сравниваем левое значение с серединой
    
        41 < 34 // skip
        i=0

        69 > 34
        j--;
        0 > 34 // skip

        0 < 3
        меняем индексы 0 и 3 местами

        на этом этапе получаем массив 0 67 34 41 69

        выполяем цикл, пока i<=j

        0 < 34 
        i++;
        67 < 34 //skip

        41 > 34 //skip

        1 < 3
        swap
        0 41 34 67 69

        
        41 < 34 // skip

        67 > 34 
        j--
        34 > 34 //skip

        1<2
        swap
        0 34 41 67 69

    */
    int i = 0;            // i = нулевой индекс
    int j = l - 1;        // j = последний индекс
    int mid = arr[l / 2]; // mid = значение в середине массива
    int tmp(0);

    cout << endl << "Mid: " << mid << endl;

    do
    {
        while (arr[i] < mid) //пока левое значение меньше середины перебираем массив до ближайшего к центру
        {
            i++;
            cout << endl
                 << "i cyc: " << i;
        }

        while (arr[j] > mid) // пока правое значение больше среднего перебираем до ближайшего к центру
        {
            j--;
            cout << endl
                 << "j cyc: " << j << endl
                 << "arr[j]: " << arr[j] << endl;
        }

        if (i <= j) // меняем местами элементы
        {
            tmp = arr[i];    //записываем в буфер значение одной из переменных
            arr[i] = arr[j]; //присваиваем одному другое
            arr[j] = tmp;    //возвращаем сохраненное значение в противоположный элемент
            cout << endl
                 << "arr i sw: " << arr[i] << " arr j sw: " << arr[j] << endl;
            printarr(arr, l);
            i++;
            j--;
            cout << "i++: " << i << " j++: " << j << endl;
        }
    } while (i <= j);

    cout << endl << "end of swap. " << "recursive next. i: " << i << " j: " << j << endl << endl;

    // вот до этого момента все понятно, а дальше начинаю путаться мал мал. из за j i входных. Просто нужно доработать кейс на бумаге.

    if (j > 0)
    {
        cout << endl
             << "left" << endl;
        printarr(arr, l);
        quicksort(arr, j + 1);
    }

    if (i < l)
    {
        cout << endl
             << "right" << endl;
        printarr(arr, l);
        quicksort(&arr[i], l - i);
    }
}

void insertion(int arr[100], int l)
{
    // сортировка вставками
    // В данном методе мы делим массив на 2 части, сортированую и нет
    // после чего присваиваем сортированй части первое значение массива
    // далее мы берем n+1 индекс и присваем ему значение key (заданное как n+1)
    // если инде

    /*
входные данные: 41 67 34 0 69

пока у нас есть длинна массива -1 мы делаем:

буфер1 = 67 (arr[i] значение)
буфер2 = 0 (i-1 индекс)

пока индекс буфера2 (0) больше или равно нулю и значение массива с индексом буфера2 (arr[0]) больше значения буфера1 (arr[i])
мы присваиваем индексу буфер2+1 значение буфер2
массив приобретает вид 41 67 34 0 69

далее уменьшаем буфер2 на единицу
бфуер2 = i-1-1 = 0
далее присва

сравниваем значение с индексом 1 и все

41 67 34 0 69

i = 2
key = 34
j = 1

while
arr[j+1] = arr[j] = 41 34 67 0 69
j = 0
arr j+1 = key = 34

т.к. arr[j / 41] > key34 цикл перестановки выполняется еще раз.

*/

    int key(0); // перменная для хранения n+1 элемента перебираемого массива
    int j(0);   // переменная для хранения n элемента массива

    for (int i = 1; i < l; i++) // пока индес, меньше чем длинна массива выполняется цикл
    {
        key = arr[i];                  //задаем первому буферу переменную под индексом n+1
        j = i - 1;                     // задаем второму буферу индекс n
        while (j >= 0 && arr[j] > key) //пока индекс больше или равен 0 и элемент массива с этим индесом больше чем следующий элемент (key = n+1)
        {
            arr[j + 1] = arr[j]; //присваиваем переменную n+1 на n
            j--;                 //
            arr[j + 1] = key;    //присваиваем индексу n+1 значение n+1
        }
    }
}

void printarr(int arr[100], int l)
{

    cout << endl
         << "Print array: "
         << endl;

    for (int i = 0; i < l; i++)
    {
        cout << arr[i] << " ";
    }

    cout << endl
         << endl;
}

void findI(int arr[100], int l, int find)
{
    int finder(0);
    for (int i = 0; i < l; i++)
    {
        if (arr[i] == find)
        {
            finder = i;
            cout << endl << "finder cycle check = " << finder <<endl;
            break;
        }
    }
    cout << endl
         << endl
         << "Index is: " << finder << endl;
}