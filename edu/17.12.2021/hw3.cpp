#include <iostream>
#include <cmath>
// 1) написать функцию сортировки массива.
// На вход подаётся массив и длина, функция сортирует (выбрать любую сортировку) и выводит отсортированный массив.

// Ещё одна задача: написать функцию (целочисленную)  нахождения индекса введённой переменной из отсортированного массива.
// На вход подаётся: длина массива и переменная. (По условию сделаем так, что переменная находится в массиве 100 проц).

// Особенность: проход по всему массиву с нулевого эт-та не эффективно)
// Думай как по-другому найти индекс эл-та.
// Подсказка: всегда можно отсекать половину)

// #include <ctime>

using namespace std;

void insertion(int arr[100], int l);
void quicksort(int arr[100], int l);
void printarr(int arr[100], int l);
void qsortRecursive(int *mas, int size);

int main()
{
    int arr[100];
    int l(0), buff(0);
    cout << "Insert array lenght: ";
    cin >> l;

    for (int i = 0; i < l; i++)
    {
        arr[i] = rand() % 100;
        cout << arr[i] << " ";
    }

    // quicksort(arr, l);
    qsortRecursive(arr, l);
    printarr(arr, l);
}

void quicksort(int arr[100], int l)
{
    /*  быстрая сортировка делит массив на две части и перекидывает элементы влево (меньше) и вправо (больше)
        функция рекурсивная и и вызывает сама себя, сортируя каждые две доли, которые получаются от разделения
        
        входные данные: 41 67 34 0 69
        записываем значение из середины массива = 34
        сравниваем левое значение с серединой
    
        41 < 34 // skip
        i=0

        69 > 34
        j--;
        0 > 34 // skip

        0 < 3
        меняем индексы 0 и 3 местами

        на этом этапе получаем массив 0 67 34 41 69

        выполяем цикл, пока i<=j

        0 < 34 
        i++;
        67 < 34 //skip

        41 > 34 //skip

        1 < 3
        swap
        0 41 34 67 69

        
        41 < 34 // skip

        67 > 34 
        j--
        34 > 34 //skip

        1<2
        swap
        0 34 41 67 69

    */
    int i = 0;            // i = нулевой индекс
    int j = l - 1;        // j = последний индекс
    int mid = arr[l / 2]; // mid = значение в середине массива
    int tmp(0);

    do
    {
        while (arr[i] < mid) //пока левое значение меньше середины перебираем массив до ближайшего к центру
        {
            i++;
            cout << endl
                 << "i cyc: " << i;
        }

        while (arr[j] > mid) // пока правое значение больше среднего перебираем до ближайшего к центру
        {
            j--;
            cout << endl
                 << "j cyc: " << j;
        }

        if (i <= j) // меняем местами элементы
        {
            tmp = arr[i];    //записываем в буфер значение одной из переменных
            arr[i] = arr[j]; //присваиваем одному другое
            arr[j] = tmp;    //возвращаем сохраненное значение в противоположный элемент
            cout << endl
                 << "arr i sw: " << arr[i] << " arr j sw: " << arr[j] << endl;
            printarr(arr, l);
            i++;
            j--;
            cout << "i++: " << i << " j++: " << j << endl;
        }
    } while (i <= j);

    // вот до этого момента все понятно

    //Левая сортировка работает нормально кажется
    if (j > 0)
    {
        cout << endl
             << "left" << endl;
        printarr(arr, l);
        quicksort(arr, j + 1);
    }

    //правая сортировка все ломает
    if (i < l)
    {
        cout << endl
             << "right" << endl;
        printarr(arr, l);
        quicksort(arr, l - i);
    }
}

void qsortRecursive(int *mas, int size)
{
    //Указатели в начало и в конец массива
    int i = 0;
    int j = size - 1;

    //Центральный элемент массива
    int mid = mas[size / 2];

    cout <<endl <<"mid: "<< mid << endl<< endl;

    //Делим массив
    do
    {
        //Пробегаем элементы, ищем те, которые нужно перекинуть в другую часть
        //В левой части массива пропускаем(оставляем на месте) элементы, которые меньше центрального
        while (mas[i] < mid)
        {
            i++;
        }
        //В правой части пропускаем элементы, которые больше центрального
        while (mas[j] > mid)
        {
            j--;
        }

        //Меняем элементы местами
        if (i <= j)
        {
            int tmp = mas[i];
            mas[i] = mas[j];
            mas[j] = tmp;
            cout << endl
                 << "arr i sw: " << mas[i] << " arr j sw: " << mas[j] << endl;
            printarr(mas, size);
            i++;
            j--;
            cout << "i++: " << i << " j++: " << j << endl;
        }
    } while (i <= j);

    //Рекурсивные вызовы, если осталось, что сортировать
    if (j > 0)
    {
        //"Левый кусок"
        cout << endl
             << "left" << endl;
        printarr(mas, size);
        qsortRecursive(mas, j + 1);
    }
    if (i < size)
    {
        //"Првый кусок"
        cout << endl
             << "right" << endl;
        printarr(mas, size);
        qsortRecursive(&mas[i], size - i);
    }
}

void insertion(int arr[100], int l)
{
    // сортировка вставками
    // В данном методе мы делим массив на 2 части, сортированую и нет
    // после чего присваиваем сортированй части первое значение массива
    // далее мы берем n+1 индекс и присваем ему значение key (заданное как n+1)
    // если инде

    /*
входные данные: 41 67 34 0 69

пока у нас есть длинна массива -1 мы делаем:

буфер1 = 67 (arr[i] значение)
буфер2 = 0 (i-1 индекс)

пока индекс буфера2 (0) больше или равно нулю и значение массива с индексом буфера2 (arr[0]) больше значения буфера1 (arr[i])
мы присваиваем индексу буфер2+1 значение буфер2
массив приобретает вид 41 67 34 0 69

далее уменьшаем буфер2 на единицу
бфуер2 = i-1-1 = 0
далее присва

сравниваем значение с индексом 1 и все

41 67 34 0 69

i = 2
key = 34
j = 1

while
arr[j+1] = arr[j] = 41 34 67 0 69
j = 0
arr j+1 = key = 34

т.к. arr[j / 41] > key34 цикл перестановки выполняется еще раз.

*/

    int key(0); // перменная для хранения n+1 элемента перебираемого массива
    int j(0);   // переменная для хранения n элемента массива

    for (int i = 1; i < l; i++) // пока индес, меньше чем длинна массива выполняется цикл
    {
        key = arr[i];                  //задаем первому буферу переменную под индексом n+1
        j = i - 1;                     // задаем второму буферу индекс n
        while (j >= 0 && arr[j] > key) //пока индекс больше или равен 0 и элемент массива с этим индесом больше чем следующий элемент (key = n+1)
        {
            arr[j + 1] = arr[j]; //присваиваем переменную n+1 на n
            j--;                 //
            arr[j + 1] = key;    //присваиваем индексу n+1 значение n+1
        }
    }
}

void printarr(int arr[100], int l)
{

    cout << endl
         << "Print array: "
         << endl;

    for (int i = 0; i < l; i++)
    {
        cout << arr[i] << " ";
    }

    cout << endl
         << endl;
}